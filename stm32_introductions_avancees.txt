*************************************************************************************************************************
*   				 DEVELOPPEMENTS AUTOUR DE MICROCONTROLEUR						*
*		     				STM32 AVANCED								*
*															*
*************************************************************************************************************************
Le stm32 est sur la base ARM qui utilise la convention little endian donc du poids faible en premier vers le poids fort.
C’est-à-dire que pour une variable locale de 4 octets et une variable Carac de 3 octets.
Nous avons pour ranger la mémoire : une valeur de 32 bits, occupe 4 adresse consécutives : 
    				          1111 1111 . 1111 1111 . 1111 1111 . 1111 1111   (4 octets = 8bits => 4*8=32)
2e3=8 + 2e2=4 + 2e1=2 + 2e0=1 = 0XFF    0X    FF          FF          FF          FF                                          
La première stock le poids faible, la seconde le poids suivant ainsi de suite ...
Mais dans char Carac[3] = {10, '3', 'A'} est la valeur dans la table ascci en hexa { 10:0X0A  '3':0X33  'A'=0x41 }
Chaque case du tableau correspond à un seul octet et donc l'inversion de poids faible et fort n'est pas nécessaire,
dans un tableau mais pour int locale=0X1A2B3C4D c'est bien little endian.
Pour les int valeurs codées sur 16bits (short int) effectivement ici on accentue le avec short puisque en embarqué
nous voulons réduire au maximum la taille de mémoire. Mai revenons le short int (16bits) où l'adresse la plus
basse (8 bits de poids faible) doit être paire (termine par un bit à 0) donc 32bits.
Comme locale l'adresse la plus basse doit être doublement paire (2 dernier bits sont à 0)
Mais pour les 64bits le problème ne se propage pas puisqu'il lit par 2 la lecture successives de 32 bits.
mem:
0X20000000: 4D  3C  2B  1A     int locale=0X1A2B3C4D
0X20000004: 0A  33  41  00     char Carac[3] = { 10:0X0A  '3':0X33  'A'=0x41 }


 Ce qui nous amène au type de variable:
 _______________________________________________________________________________
|Type			| mem (Bits)    |  valeur 				|
|================================================================================
|bit			| 1	    	|  0   to  1				|	
|--------------------------------------------------------------------------------
|signed char		| 8 		| -128 to 127				|
|--------------------------------------------------------------------------------
|unsigned char		| 8 		| 0    to 255				|
|--------------------------------------------------------------------------------
|int			| 16 		| -32768 to 32767			|	
|--------------------------------------------------------------------------------
|unsigned int		| 16		| 0    to 63535      			|
|--------------------------------------------------------------------------------
|short	int		| 16 		| -32768  to 32767   			|
|--------------------------------------------------------------------------------
|long int		| 32		| -2.147.483.648 to  2.147.483.647 	|	
|--------------------------------------------------------------------------------
|unsigned long	int	| 32 		| 0  to  4.294.967.295			|		
|--------------------------------------------------------------------------------
|float			| 32		| -1.175e-38 to 3.402e38		|	
|--------------------------------------------------------------------------------
|double			| 32		| -1.175e-38 to 3.402e38		|			
|---------------------------------------------------------------------------------------------------------
|boolean(true/false)	| 1 octet c'est la valeur minimale à stocker 00000001bits (le reste sont remplis)|		
|---------------------------------------------------------------------------------------------------------


Actions sur les registres comment ? :    opération (<< >>  & |) (décalage, ET, OU)
------------------------------------
init   		 b7   b6  b5  b4  b3  b2  b1  b0
       		 0    0   0   0   0   0   0   0
1<<4   		 0    0   0   1   0   0   0   0
1<<0		 0    0   0   0   0   0   0   1
Masque(ou)---------------------------------------         
(1<<0) | (1<<4)  0    0   0   1   0   0   0   1
Masque inverse-----------------------------------
NOT ou ~
(1<<0) | (1<<4)  1    1   1   0   1   1   1   0
Masque &-----------------------------------------
		 0    0   0   0   0   0   0   0
& ~(0xFF) =      0    0   0   0   0   0   0   0   

Si nous souhaitons manipuler le registre GPIOx_IDR il faut chercher l’adresse de base du périphérique, 
puis décaler cette adresse de la valeur d’offset propre au registre (très fastidieux mais c'est comme ça)
Mais c'est pourquoi ST-MicroElectronics fournie des fichiers de configuration comme le fichier STM32f10x.h 
qui contient l’ensemble de définitions pour nous aider.
Typedef  struct{
   __IO uint32_t  CRL;          #define PERIPH_BASE ((uint32_t)0X40000000)
   __IO uint32_t  CRH;          #define APB2PERIPH_BASE (PERIPH_BASE + 0X10000)
   __IO uint32_t  IDR;          #define GPIOB_BASE  (APB2PERIPHçBASE + 0X0C00)
   __IO uint32_t  ODR;
   __IO uint32_t  BSRR;         #define GPIOB  ((GPIO_TypeDef *) GPIOB_BASE)
   __IO uint32_t  BRR;
   __IO uint32_t  LCKR;         #En remontant la chaine: 0x40000000+0x10000+0x0C00 soit 0x4001 0C00
} GPIO_TypeDef;                 #  Qui est bien l’adresse de base du GPIOB fournie par la documentation

Pour l'accès au registre il suffit de lire le registre IDR du port B à écrire value=GPIOB->IDR;
 								value prend la l'adresse 0x40010C00
Vous savez comment trouver et manipuler l’adresse d’un registre pour le STM32!!

Mais qu'est ce qu'il y a comme registre dans un microcontrôleur ?
----------------------------------------------------------------
L'Architecture ARM de type RISC repose sur 17 REGISTRES :
   [
     R0 à R12    (Registres généraux) 
     R13 le registre SP (pointeur de pile) PILE SYSTEME, elle contient l’adresse accessible en mémoire vive 
                                                         pour stocker des informations temporaires  
                                                         pour le bon déroulement de l’ensemble.
     R14 le registre LR (de lien) 
     R15 le registre PC (pointeur de programme) il contient l’@ courante du programme en cours et progresse 
						dans l’exécution du programme.
     R16 le registre xPSR (status) se décline (APSR, EPSR,IPSR). 
                        Et se complète avec 4 registres spéciaux
                        PRIM, FAULTMASK, BASEPRI (gestion d’exception), CONTROL (gère le niveau de privilège)
   ]


*************************************************************************************************************************
*     			GPIO (general purpose input/output) et oui une pin peut être une entrée ou une sortie		*
*************************************************************************************************************************
Ce sont des ports disponibles sur la carte Nucleo.
Ce sont des ports génériques et doivent être configurés.
8 configurations possibles pour une pin: 
input  Analog		  :entrée permettant une acquisition directe de la tension(état binaire pas connue sur le registre)
input  Floating           :mode de base pour une entrée, aucune tension appliquée la valeur n'est pas connue.
input  Pull-up/pull-down  :entrée où il est possible de fixer la valeur par défaut à 0(pulldown) 1(pullup)
input  Analog             :Non utiilisé

Output Push-pull	  :mode de sortie dans lequel la tension appliquée à la broche est toujours forcée à 0 ou 1.
Output Open-drain         :mode de sortie dans lequel le niveau de tension haut est fixé par le circuit connecté à la broche
Ouput  Alternat push-pull :mode de sortie identique au mode push-pull, mais l’état de la broche est contrôlé par un 
                           autre périphérique que le port
Output Alternat open-drain:mode de sortie identique au mode open-drain, mais l’état de la broche est contrôlé par un 
                           autre périphérique que le port

Comprendre la différence entre le Push-Pull et Open-Drain :
Si vous choisissez un drain ouvert, la broche de sortie peut être LOW (Gnd) ou flottant tandis
si vous choisissez Push Pull, la broche de sortie peut être HAUT ou BAS.


Il y a 16 broches sur un port, il faut 4 bits par broche pour configurer e/s. (16*4=64 bits)
Soit 64 bits pour configurer l’ensemble des broches d’un port. 
Or un registre fait 32 bits; il faut donc 2 registres pour configurer l’ensemble des broches du même port d’où 
l’existence de 2 registres : CRL et CRH.
CRL (L pour low) permet de configurer les broches de 0 à 7.
CRH (H pour high) de 8 à 15.

Si on veut une sortie Output push-pull, il faudrra fixer 0b0001 aux bits b11 b10 b9 b8 dans le CRH.
il faudra regarder la documentation pour savoir l'initialisation de début du registre CRH.
GPIOA->CRH = GPIOA->CRH & ~(0xF << 8); // Mise à 0 des bits    	 b11 b10 b9 b8   
GPIOA->CRH = GPIOA->CRH | (0x01 << 8); // Mise à 1 du bit b8   	 0   1   0  0 
           						       & 0   0   0  0
           						       = 0   0   0  0
           						       | 0   0   0  1                                         
           						       = 0   0   0  1
Ecrire sur un port:
le registre ODR dont les 16 premiers bits fixent l’état de chaque broche en sortie d’une port.
Pour mettre à 1 la broche 8 du port B nous fixons à 1 le bit 8 de ODR
GPIOB->ODR = GPIOB->ODR | (1 << 8);

Remarque:
On remarquera qu’étant donné que le STM32 n’a pas de mémoire « bit accessible » l’affectation d’un bit nécessite 
la lecture d’un registre, le masquage adéquat de la valeur ainsi lue et enfin l’affectation du résultat sur le registre.
Soit au moins 3 opérations.
Il existe cependant dans l’architecture du Cortex une alternative qui permet d’éviter cela (le « bit-banding »). 
L'idée est de mettre en correspondance un bit avec un mot. 
STMicro a utilisé ce principe pour créer des registres de SET et de RESET des GPIO.  
Ce sont les registres BRR (Bit Reset Register) et BSRR (Bit Set and Reset Register). 
Chaque bit de ces registres correspond à un bit des GPIO et seul le niveau logique 1 a un effet. 
Le programmeur peut donc directement affecter le valeur 1 en mettant à 1 le bit correspondant du registre BSRR (action SET)
et affecter le valeur 0 en mettant 1 le bit correspondant du registre BRR (action RESET : on agit en mettant 1 pour forcer 
la mise à 0, ce qui peut être déroutant en première lecture).

Alors Comment fait-on pour allumer une led avec les registres ?
--------------------------------------------------------------
 -----------------------------------------------------------------------
| Pour faire fonctionner un GPIO il faut : 				|
|         activer l’horloge + activer GPIOA + activer le port PA5 (0|1) |
 -----------------------------------------------------------------------
#include "stm32l4xx.h"
//clignote la led sur le port PA5 une led de test sur la nucleo
int main(void)
{
   volatile unsigned int i =0;
   RCC -> AHB2ENR|= 1<<0;                              //Activer la bonne horloge
   GPIOA->MODER &= 0xFFFFF7FF;//GPIOA->MODER &= 0<<11  //Activer le port GPIOA output mode5[01]
   while(1)
   {for (i= 0; i < 50000; i++)
	GPIOA -> ODR= (1<<5); //on affecte 1 au bit du rang 5
                              //GPIOA -> BSRR= (1<<5);
    for (i = 0; i < 50000; i++)
	GPIOA -> ODR= (0<<5); //PA5 à 0  ////GPIOA -> BSRR= (1<<21);}
   }
}



































